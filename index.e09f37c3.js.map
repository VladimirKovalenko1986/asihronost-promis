{"mappings":"AAkQUA,QAAFC,IAAI,oBACI,IAAIC,SAAQ,CAACC,EAAKC,KAChCC,YAAW,KACTL,QAAQC,IAAI,sBACZ,MAAMK,EAAO,CACXC,GAAI,EACJC,KAAM,8BACNC,MAAO,YAGJH,EAAKC,IACRH,EAAI,IAAIM,MAAM,WAEhBP,EAAIG,EAAK,GACR,IAAK,IAoBPK,MAAKL,GACG,IAAIJ,SAAQC,IACjBH,QAAQC,IAAI,iBACZK,EAAKG,MAAQ,WACbN,EAAIG,EAAK,MAGZK,MAAKL,GAAQN,QAAQC,IAAIK,KACzBM,OAAMC,GAAOb,QAAQc,MAAMD,KAC3BE,SAAQ,IAAMf,QAAQC,IAAI","sources":["src/js/promis.js"],"sourcesContent":["// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// * Promis\n// const promise = new Promise((resolve, reject) => {\n//   const canFullfill = Math.random() > 0.5;\n\n//   setTimeout(() => {\n//     if (canFullfill) {\n//       resolve('Все ок');\n//     }\n\n//     reject('Промис вызван с ошибкой');\n//   }, 1000);\n// });\n\n// Выводим значение промиса\n\n// 1 способ\n// * Внутрение результаты\n// promise.then(\n//   result => {\n//     console.log(result);\n//   },\n//   error => {\n//     console.log(error);\n//   }\n// );\n\n// 2 способ\n//* Можно передать внешними функциями\n\n// promise.then(onFulfilled, onRejeccted);\n\n// function onFulfilled(result) {\n//   console.log(result);\n// }\n\n// function onRejected(error) {\n//   console.log(error);\n// }\n\n// * Цепочка промисов\n// promise\n//   .then(result => {\n//     console.log(result);\n\n//     return 5;\n//   })\n//   .then(x => {\n//     console.log(x);\n\n//     return 10;\n//   })\n//   .then(y => {\n//     console.log(y);\n//   });\n\n// * Передача ошибки\n\n// promise\n//   .then(onFulfilled)\n//   .then(x => {\n//     console.log(x);\n\n// Метод который выкидывет ошибку\n//   throw new Error('Ошибка во втором ');\n\n//   return 10;\n// })\n// .then(y => {\n//   console.log(y);\n// })\n// автоматически отлавливает все ошибки\n// .catch(error => console.log(error))\n// функция которая будет выполнена в любом случае\n// .finally(() => console.log('Я буду выполнен в любом случае!!'));\n\n// * Промисификация функции\n\n// const makeOrder = dish => {\n//   const DALEY = 1000;\n\n//   return new Promise((resolve, reject) => {\n//     const passed = Math.random() > 0.5;\n\n//     setTimeout(() => {\n//       if (passed) {\n//         resolve('Вот ваше блюдо!');\n//       }\n//       reject('Извини закончились продукты!');\n//     }, DALEY);\n//   });\n// };\n\n// makeOrder('пирожок').then(onMakeOrderSuccess).catch(onMakerOrderError);\n\n// function onMakeOrderSuccess(result) {\n//   console.log('onMakeOrderSuccess');\n//   console.log(result);\n// }\n\n// function onMakerOrderError(error) {\n//   console.log('onMakerOrderError');\n//   console.log(error);\n// }\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// * Живой пример\n\n// const makePromise = () => {\n//   return new Promise((resolve, reject) => {\n//     const passed = Math.random() > 0.5;\n\n//     setTimeout(() => {\n//       if (passed) {\n//         resolve('Ку-ку это resolve');\n//       }\n//       reject('Ку-ку это reject');\n//     }, 2000);\n//   });\n// };\n\n// makePromise()\n//   .then(result => console.log(result))\n//   .catch(error => console.log(error));\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// * Иподром\n\n// Набор коней\n// const horses = [\n//   'Secretariat',\n//   'Eclips',\n//   'West Australian',\n//   'Flying Fox',\n//   'Seabiscult',\n// ];\n\n//Переменная для автоматической простановки порядкового номера\n// let raceCounter = 0;\n\n// const refs = {\n//   startBtn: document.querySelector('.js-race-btn'),\n//   winnerFiled: document.querySelector('.winner'),\n//   progressField: document.querySelector('.progress'),\n//   tableBody: document.querySelector('.js-results-table > tbody'),\n// };\n\n// По нажатию на кнопку запускаем всх наших лошадей\n\n// refs.startBtn.addEventListener('click', onStart);\n\n// * Делаем функции\n\n// function onStart() {\n//   raceCounter += 1;\n// Массив промисов\n// const promises = horses.map(run);\n// Перед заездом очищаем строку победителя\n// updateWinnerFiled('');\n// Записываем в текст что заезд начался\n//   updateProgresFiled('Заезд начался ставки не принимаються!');\n\n//   determineWinner(promises);\n//   waiForAll(promises);\n// }\n\n// function updateWinnerFiled(message) {\n//   refs.winnerFiled.textContent = message;\n// }\n\n// function updateProgresFiled(message) {\n//   refs.progressField.textContent = message;\n// }\n\n// Чтобы обновлялась таблица\n// function updateResultTable({ horse, time, raceCounter }) {\n//   const tr = `<tr><td>${raceCounter}</td><td>${horse}</td><td>${time}</td></tr>`;\n//   refs.tableBody.insertAdjacentHTML('beforeend', tr);\n// }\n\n// function determineWinner(horsesP) {\n//   Promise.race(horsesP).then(({ horse, time }) => {\n//     updateWinnerFiled(`Победитель ${horse}, финишировал за ${time} времени`);\n//     updateResultTable({ horse, time, raceCounter });\n//   });\n// }\n\n// function waiForAll(horsesP) {\n//   Promise.all(horsesP).then(x => {\n//     updateProgresFiled('Заезд окончен, принимаються ставки');\n//   });\n// }\n//???????????????????????????????????????????????????????????????\n\n// console.log(\n//   '%c Заезд начался ставки не принимаються!',\n//   'color: brown; font-size: 14px;'\n// );\n\n// Функция которая будет запускать одного коня\n// function run(horse) {\n//   return new Promise(resolve => {\n//     const time = getRandomTime(2000, 3500);\n\n//     setTimeout(() => {\n//       resolve({ horse, time });\n//     }, time);\n//   });\n// }\n\n// run(horses[0]).then(x => console.log(x));\n// run(horses[1]).then(x => console.log(x));\n\n// * Обработка массивов промисов\n\n// race - берет первый который выполнился не дожидаясь всех остальных\n// Promise.race(promises).then(({ horse, time }) => {\n//   console.log(\n//     `%c Победитель ${horse}, финишировал за ${time} времени`,\n//     'color: blue; font-size: 14px;'\n//   );\n// });\n// all - берет все которые находтся в масиве\n// Promise.all(promises).then(x => {\n//   console.log(x);\n//   console.log(\n//     '%c Заезд окончен, принимаються ставки',\n//     'color: red; fond-size: 14px;'\n//   );\n// });\n\n// функция случайной лошади\n\n// function getRandomTime(min, max) {\n//   return Math.floor(Math.random() * (max - min + 1) + min);\n// }\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// * Приклад - запит на сервер\n\n// Без  промісів\n// console.log('Request data ...');\n\n// setTimeout(() => {\n//   console.log('Prepering data ...');\n\n//   const data = {\n//     id: 1,\n//     text: 'lorem ipsum dolor sit amet.',\n//     statu: 'inpotant',\n//   };\n\n//   setTimeout(() => {\n//     console.log('Data received:', data);\n//   }, 2000);\n// }, 2000);\n\n// З промісами\nconsole.log('Request data ...');\nconst promise = new Promise((res, rej) => {\n  setTimeout(() => {\n    console.log('Prepering data ...');\n    const data = {\n      id: 1,\n      text: 'lorem ipsum dolor sit amet.',\n      statu: 'inpotant',\n    };\n\n    if (!data.id) {\n      rej(new Error('No id!'));\n    }\n    res(data);\n  }, 2000);\n});\n\n// Не дуже гарний варіант\n// promise\n//   .then(data => {\n//     const p = new Promise(res => {\n//       console.log('Data chanched');\n//       data.statu = 'ordinary';\n//       res(data);\n//     });\n\n//     p.then(data => console.log(data));\n//   })\n//   .catch(err => console.log(err))\n//   .finally(() => console.log('Promise end'));\n\n// Ідеальний варіант\n\npromise\n  .then(data => {\n    return new Promise(res => {\n      console.log('Data chanched');\n      data.statu = 'ordinary';\n      res(data);\n    });\n  })\n  .then(data => console.log(data))\n  .catch(err => console.error(err))\n  .finally(() => console.log('Promise end'));\n"],"names":["console","log","Promise","res","rej","setTimeout","data","id","text","statu","Error","then","catch","err","error","finally"],"version":3,"file":"index.e09f37c3.js.map"}